You don't need to multiply polynomials. Bruteforce way is

```haskell
f = maximum . map length . group . sort . foldM ((. enumFromTo 0) . map . (+)) 0
```

which gets a list of powers of primes and returns the maximum length of an antichain of S(N), where N is product of primes in their powers.
Suppose, that we have this number: `N = 2^1 * 5^2 * 7^4`. Then the list of powers is `[1, 2, 4]`. When we forming a divisor, we can get from `0` to `1` twos, from `0` to `2` fives and from `0` to `4` sevens. Then we sum these powers up and get a list of numbers of primes in every divisor of `N`:
```
[0,1,2,3,4,1,2,3,4,5,2,3,4,5,6,1,2,3,4,5,2,3,4,5,6,3,4,5,6,7]
```

That's what

```haskell
foldM ((. enumFromTo 0) . map . (+))
```

does. Then we just sort this list and see, which number of primes gives the biggest set of factors. There always exists an antichain with maximum length and the same number of primes in the factorization of every divisor in it, because if there exists an antichain, that for which the latter condition doesn't hold, then you can multiply "short" divisors by some random primes (primes are from the factorization of `N`, of course) to improve the set, and it still would be an antichain with the maximal length.
But there is a smarter way. The list of prime powers is `[2, 3]`. Then steps of bruteforce are:

```
1) 2 gives [0, 1, 2]
2) if previous == 0 then 3 gives [0, 1, 2, 3]
   if previous == 1 then 3 gives [1, 2, 3, 4]
   if previous == 2 then 3 gives [2, 3, 4, 5]
Or
1) (0, 1), (1, 1), (2, 1)
2) (0, 1), (1, 2), (2, 3), (3, 3), (4, 2), (5, 1)
Or
1) 111
2) 123321
```

where `X` in `(X, Y)` is the number of primes in the factorization of divisor and `Y` is the length of produced antichain.

You can get the second from the first:

```
 111
+ 111   -> 123321
+  111
+   111
```

If the second power is `5` then

```
 111
+ 111   
+  111    -> 12333321
+   111
+    111
+     111
```

So you just do this operation `n + 1` times. Initial value is `1`, that's how we get `111` from `[2]`. The maximum length is in the middle. So you can get one value from another.

```
[2,5] is 12333321, then [2,6] is
 111
+ 12333321 -> 123333321
```

```
and [2,6,1] is
 123333321
+ 123333321 -> 1356666531
```
Some examples:

```
([],[1])
([1],[1,1])
([1,1],[1,2,1])
([1,1,1],[1,3,3,1])
([1,1,2],[1,3,4,3,1])
([1,1,3],[1,3,4,4,3,1])
([1,2],[1,2,2,1])
([1,2,1],[1,3,4,3,1])
([1,2,2],[1,3,5,5,3,1])
([1,2,3],[1,3,5,6,5,3,1])
([1,3],[1,2,2,2,1])
([1,3,1],[1,3,4,4,3,1])
([1,3,2],[1,3,5,6,5,3,1])
([1,3,3],[1,3,5,7,7,5,3,1])
([2],[1,1,1])
([2,1],[1,2,2,1])
([2,1,1],[1,3,4,3,1])
([2,1,2],[1,3,5,5,3,1])
([2,1,3],[1,3,5,6,5,3,1])
([2,2],[1,2,3,2,1])
([2,2,1],[1,3,5,5,3,1])
([2,2,2],[1,3,6,7,6,3,1])
([2,2,3],[1,3,6,8,8,6,3,1])
([2,3],[1,2,3,3,2,1])
([2,3,1],[1,3,5,6,5,3,1])
([2,3,2],[1,3,6,8,8,6,3,1])
([2,3,3],[1,3,6,9,10,9,6,3,1])
([3],[1,1,1,1])
([3,1],[1,2,2,2,1])
([3,1,1],[1,3,4,4,3,1])
([3,1,2],[1,3,5,6,5,3,1])
([3,1,3],[1,3,5,7,7,5,3,1])
([3,2],[1,2,3,3,2,1])
([3,2,1],[1,3,5,6,5,3,1])
([3,2,2],[1,3,6,8,8,6,3,1])
([3,2,3],[1,3,6,9,10,9,6,3,1])
([3,3],[1,2,3,4,3,2,1])
([3,3,1],[1,3,5,7,7,5,3,1])
([3,3,2],[1,3,6,9,10,9,6,3,1])
([3,3,3],[1,3,6,10,12,12,10,6,3,1])
```

which was generated by

```haskell
import Control.Monad

g  []     ys    = ys
g (x:xs) (y:ys) = (x + y) : g xs ys

h pows xs k = (pows, xs) : do
  guard $ k > 0
  (pow, xs') <- zip [1..] $ take 3 $ tail $ iterate (g xs . (0:)) xs
  h (pows ++ [pow]) xs' (k - 1)
    -- due to the symmetry we could write `h (pow:pows) xs' (k - 1)` 

main = mapM_ print $ h [] [1] 3
```

I don't post my solution to this problem, because it's unoptimized.